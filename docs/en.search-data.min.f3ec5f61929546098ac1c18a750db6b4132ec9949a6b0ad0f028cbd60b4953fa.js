'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/knackpy/docs/api-reference/','title':"API Reference",'section':"Docs",'content':"knackpy #  knackpy.formatters #  default #  default(value: object) Formatter functions handle Knack values by returning a formatted (aka, humanized) value.\nThe default() formatter handles any field type for which another formatter function has not been defined. It simply returns the input value without additional formatting.\nYou\u0026rsquo;ll notice that each formatter function\u0026rsquo;s name matches its field type. If you want to write a custom formatter, do that.\nSee also: knackpy.Fields\ndate_time #  date_time(value, timezone=datetime.timezone.utc) Given a unix timestamp and a timezone, return the timestamp in ISO format in local time with TZ offset str.\nExpecting a Knack datetime field value like so: ``` \u0026ldquo;date_time\u0026rdquo;: { \u0026ldquo;am_pm\u0026rdquo;: \u0026ldquo;PM\u0026rdquo;, \u0026ldquo;date\u0026rdquo;: \u0026ldquo;09/11/2019\u0026rdquo;, \u0026ldquo;date_formatted\u0026rdquo;: \u0026ldquo;09/11/2019\u0026rdquo;, \u0026ldquo;hours\u0026rdquo;: \u0026ldquo;04\u0026rdquo;, \u0026ldquo;iso_timestamp\u0026rdquo;: \u0026ldquo;2019-09-11T16:14:00.000Z\u0026rdquo;, \u0026ldquo;minutes\u0026rdquo;: \u0026ldquo;14\u0026rdquo;, \u0026ldquo;time\u0026rdquo;: 974, \u0026ldquo;timestamp\u0026rdquo;: \u0026ldquo;09/11/2019 04:14 pm\u0026rdquo;, \u0026ldquo;unix_timestamp\u0026rdquo;: 1568218440000, }\n \u0026lt;a name=\u0026quot;knackpy.formatters.connection\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; #### connection ```python connection(value) Return a string of comma-separated values\nknackpy.models #  knackpy.fields #  get_id_field_args #  get_id_field_args() TODO\n id field is a global field def. weird, right? field_defs should be immutable for this reason  set_field_def_views #  set_field_def_views(key: str, scenes: list) Update FieldDef\u0026rsquo;s views property to include a list of all view keys that use this field.\nTODO: make side effect of FieldDef\u0026hellip;and document\nFieldDef Objects #  class FieldDef() Knack field defintion wrapper\nfield_defs_from_metadata #  field_defs_from_metadata(metadata: dict) Generate a list of FieldDef\u0026rsquo;s from Knack metadata. Note the \u0026ldquo;set_field_def_views()\u0026rdquo; side effect, which assigns to prop \u0026ldquo;views\u0026rdquo; a list of view keys which use the field.\nArguments:\n metadata dict - Knack application metadata dict.  Returns:\n list - A list of FieldDef instances.  Field Objects #  class Field(object) A container for a single column of Knack data. This is the lowest-level container in the API. The hieracrchy being: App \u0026gt; Records \u0026gt; Record \u0026gt; Field. Typically you would not construct this class directly, but instead an App, which will generate Fields via App.records().\nMore specifically, the API is designed so that you would typically interface with a Field instance through the records.Record class. That class operates on Fields by returning their values through Record[] or Record[].\nBut it\u0026rsquo;s fine to work directly with fields:\n field.value: the unformatted input value field.key: the knack field key field.name: the knack field name  And the method of interest here is .format(), which returns the humanized value.\nArguments:\n field_def knackpy.fields.FieldDef - A knackpy FieldDef class object value object - Anything, really. timezone [pytz.timezone] - A pytz timezone object.  format #  | format() Knack applies it\u0026rsquo;s own standard formatting to values, which are always available at the non-raw key. Knack includes the raw key in the dict when formatting is applied, allowing access to the unformatted data.\nGenerally, the Knack formatting, where it exists, is fine. However there are cases where we want to apply our own formatters, such datestamps, (where the formatted value does not include a timezone offset).\nAnd there are other cases where we want to apply additional formatting to the knack-formatted value, e.g. Timers.\nSee also: models.py, formatters.py.\nknackpy.api #  get #  get(*, app_id: str, api_key: str = None, slug: str = None, obj: str = None, scene: str = None, view: str = None, record_limit: int = None, filters: dict = None, max_attempts: int = 5, timeout: int = 30) -\u0026gt; [list, requests.Response] Get records from a knack object or view. This is the raw stuff with incorrect timestamps!\nArguments:\n app_id str - [description] api_key str, optional - [description]. Defaults to None. slug str, optional - Your organization\u0026rsquo;s slug (aka, subdomain). As found in your app metadata under accounts/slug. obj str, optional - [description]. Defaults to None. scene str, optional - [description]. Defaults to None. view str, optional - [description]. Defaults to None. max_attempts int, optional - [description]. Defaults to 5. record_limit int, optional - [description]. Defaults to None (which is handled as infinity). timeout int, optional - [description]. Defaults to 30. filters [list, dict], optional - Knack record filter dict or list. Defaults to None.  Returns:\n list - Knack records.  get_metadata #  get_metadata(*, app_id: str, slug: str = None, timeout: int = 30) -\u0026gt; dict Fetch Knack application metadata. You can find your app\u0026rsquo;s metadata at: https://api.knack.com/v1/applications/\u0026lt;app_id:str\u0026gt;.\nArguments:\n app_id str - A Knack application ID. slug str, optional - Your organization\u0026rsquo;s slug (aka, subdomain). As found in your app metadata under accounts/slug.  Returns:\n dict - A dictionary of Knack application metadata.  record #  record(*, app_id: str, api_key: str, data: dict, method: str, obj: str, slug: str = None, max_attempts: int = 5, timeout: int = 30) Create, update, or delete a Knack record.\nArguments:\n app_id str - Knack application ID # noqa:E501 string. api_key str - Knack API key. slug str, optional - Your organization\u0026rsquo;s slug (aka, subdomain). As found in your app metadata under accounts/slug. data dict - The Knack record data payload. method str - Choose from create, update, or delete. obj str, optional - The Knack object key which holds the record data. max_attempts int - The maximum number of attempts to make if a request times out. Default values that are set in knackpy.api.request. Defaults to 5. timeout int, optional - Number of seconds to wait before a Knack API request times out. Further reading: Requests docs.  Returns:\n dict - The updated or newly created Knack record data, or, if deleting a record: {\u0026quot;delete\u0026quot;: true}  upload #  upload(*, app_id: str, api_key: str, obj: str, field: str, path: str, asset_type: str, record_id: str = None, slug: str = None, max_attempts: int = 5, timeout: int = 30) Upload a file or image to Knack. This is a two-step process:\n Upload file asset to Knack storage Create/update a record that links to the file in storage  Knack docs: https://www.knack.com/developer-documentation/`file`-image-uploads\nArguments:\n app_id str - Knack application ID # noqa:E501 string. api_key str - Knack API key. obj str - The Knack object key which holds the record data. field str - The knack field key of the field you\u0026rsquo;re uploading into. path - (str): The path to the file to be uploaded. asset_type str - The type of Knack field you\u0026rsquo;re uploading to. Must be file or image. record_id str, optional - The knack record ID to which the upload will be attached. If None, will create a new record. Otherwise will update an existing record. slug str, optional - Your organization\u0026rsquo;s slug (aka, subdomain). As found in your app metadata under accounts/slug. max_attempts int - The maximum number of attempts to make if a request times out. Default values that are set in knackpy.api.request. Defaults to 5. timeout int, optional - Number of seconds to wait before a Knack API request times out. Further reading: Requests docs.  knackpy.utils #  generate_containers #  generate_containers(metadata) Returns a dict of knack object keys, object names, view keys, and view names, that serves as lookup for finding Knack app record containers (objects or views) by name or key.\nNote that namespace conflicts are highlighly likely, especially with views, whose default name in Knack is their parent object!\nIf an app has object names that conflict with view names, a ValidationError will raise when attempting to query data by that name.\nAs such, the best practice is to use keys (object_xx or view_xx) as much as possible, especially when fetching data from views.\ncorrect_knack_timestamp #  correct_knack_timestamp(mills_timestamp, timezone) You may be wondering why timezone settings are concern, given that Knackpy, like the Knack API, returns timestamp values as Unix timestamps in millesconds (thus, there is no timezone encoding at all). However, the Knack API confusingly returns millisecond timestamps in your localized timezone!\nFor example, if you inspect a timezone value in Knack, e.g., 1578254700000, this value represents Sunday, January 5, 2020 8:05:00 PM local time.\nArgs: mills_timestamp ([int]): the Knack \u0026ldquo;local\u0026rdquo; timestamp, in milliseonds timezone ([pytz.timezone]): pytz timezone object\nReturns: [int]: a real UTC timestamp\nknackpy.record #  Record Objects #  class Record(MutableMapping) A dict-like object for storing record data.\n__getitem__ #  | __getitem__(client_key) Return the field whose key or name matches the client-provided value.\nArguments:\n client_key str - A field key (e.g., \u0026ldquo;field_99\u0026rdquo;) or field name.  Returns:\n object - The field\u0026rsquo;s value (dict, list, str, int, whatever Knack has in store for you.)  __setitem__ #  | __setitem__(key, value) Bad things will happen if you re-assign record values to anything other than a field class. This is not immediately obvious, because you can assign values to the record without issue, but some operations will fail after assignment of a non-Field value. e.g., .format() and dict().\nAll that to say, we set immutable = True after init, and further attempts to setitem will raise a TypeError.\nRaises:\n TypeError - \u0026lsquo;Record\u0026rsquo; object does not support item assignment.  format #  | format(keys: bool = True, values: bool = True) Returns the record as a dict.\nArguments:\n keys bool, optional - If keys should be formatted. values bool, optional - If values should be formatted.  Returns:\n dict - A dict of the record values with formatted (aka, humaized) keys and/or values.  knackpy.app #  App Objects #  class App() Knackpy is designed around the App class. It provides helpers for querying and manipulating Knack application data. You should use the App class because:\n It allows you to query obejcts and views by key or name It takes care of localization issues It let\u0026rsquo;s you download and upload files from your app. It does other things, too.  Arguments:\n app_id str - Knack application ID # noqa:E501 string. api_key str, optional, default=None - Knack API key. metadata dict, optional - The Knack app\u0026rsquo;s metadata as a dict. If None it will be fetched on init. You can find your apps metadata here. tzinfo pytz.Timezone, optional - [description]. A pytz.Timezone object. When None, is set automatically based on the app\u0026rsquo;s metadadata. max_attempts int - The maximum number of attempts to make if a request times out. Default values that are set in knackpy.api.request. timeout int, optional - Number of seconds to wait before a Knack API request times out. Further reading: Requests docs.  info #  | info() Returns a dict of basic app information:\n Number of objects Number of scenes Number of records Number total file size  get #  | get(identifier: str = None, refresh: bool = False, record_limit: int = None, filters: typing.Union[dict, list] = None, generate=False) Get records from a knack object or view.\nNote that we accept the request params record_limit and filters here because the user would presumably want to set these on a per-object/view basis. They are not stored in state. Whereas max_attempts and timeout are set on App construction and persist in App state.\nArguments:\n identifier _str, optional*_ - an object or view key or name string that exists in the app. If None is provided and only one container has been fetched, will return records from that container. refresh bool, optional - Force the re-querying of data from Knack API. Defaults to False. record_limit int - the maximum number of records to retrieve. If None, will return all records. filters dict or list, optional - A dict or of Knack API filiters. See - https://www.knack.com/developer-documentation/`filters`. generate bool, optional - If True, will return a generator which yields knacky.Record objects instead of return a list of of them.  Returns:\nA generator which yields knackpy Record objects.\nto_csv #  | to_csv(identifier: str, *, out_dir: str = \u0026#34;_csv\u0026#34;, delimiter=\u0026#34;,\u0026#34;) -\u0026gt; None Write formatted Knack records to CSV.\nArguments:\n identifier str - an object or view key or name string that exists in the app. out_dir str, optional - Relative path to the directory to which files will be written. Defaults to \u0026ldquo;_csv\u0026rdquo;. delimiter str, optional - [description]. Defaults to \u0026ldquo;,\u0026rdquo;.  download #  | download(*, container: str, field: str, out_dir: str = \u0026#34;_downloads\u0026#34;, label_keys: list = None) Download files and images from Knack records.\nArguments:\n container str - The name or key of the object from which files will be downloaded. out_dir str, optional - Relative path to the directory to which files will be written. Defaults to \u0026ldquo;_downloads\u0026rdquo;. field str - The Knack field key of the file or image field to be downloaded. label_keys list, optional - A list of field keys whose values will be prepended to the attachment filename, separated by an underscore.  Returns:\n [int] - Count of files downloaded.  record #  | record(*, data: dict, method: str, obj: str) Create, update, or delete a Knack record.\nArguments:\n data dict - The Knack record data payload. method str - Choose from create, update, or delete. obj str, optional - The Knack object key or name which holds the record data.  Returns:\n dict - The updated or newly created Knack record data, or, if deleting a record - {\u0026quot;delete\u0026quot;: true}  "});})();