'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/knackpy/docs/api-reference/api/','title':"API",'section':"API Reference",'content':"knackpy.api #  get #  get(*, app_id: str, api_key: str = None, slug: str = None, obj: str = None, scene: str = None, view: str = None, record_limit: int = None, filters: dict = None, max_attempts: int = 5, timeout: int = 30) -\u0026gt; [list, requests.Response] Get records from a knack object or view. This is the raw stuff with incorrect timestamps!\nArguments:\n app_id str - [description] api_key str, optional - [description]. Defaults to None. slug str, optional - Your organization\u0026rsquo;s slug (aka, subdomain). As found in your app metadata under accounts.slug. obj str, optional - [description]. Defaults to None. scene str, optional - [description]. Defaults to None. view str, optional - [description]. Defaults to None. max_attempts int, optional - [description]. Defaults to 5. record_limit int, optional - [description]. Defaults to None (which is handled as infinity). timeout int, optional - [description]. Defaults to 30. filters [list, dict], optional - Knack record filter dict or list. Defaults to None.  Returns:\n list - Knack records.  get_metadata #  get_metadata(*, app_id: str, slug: str = None, timeout: int = 30) -\u0026gt; dict Fetch Knack application metadata. You can find your app\u0026rsquo;s metadata at: https://api.knack.com/v1/applications/\u0026lt;app_id:str\u0026gt;.\nArguments:\n app_id str - A Knack application ID. slug str, optional - Your organization\u0026rsquo;s slug (aka, subdomain). As found in your app metadata under accounts/slug.  Returns:\n dict - A dictionary of Knack application metadata.  record #  record(*, app_id: str, api_key: str, data: dict, method: str, obj: str, slug: str = None, max_attempts: int = 5, timeout: int = 30) Create, update, or delete a Knack record.\nArguments:\n app_id str - Knack application ID # noqa:E501 string. api_key str - Knack API key. slug str, optional - Your organization\u0026rsquo;s slug (aka, subdomain). As found in your app metadata under accounts/slug. data dict - The Knack record data payload. method str - Choose from create, update, or delete. obj str, optional - The Knack object key which holds the record data. max_attempts int - The maximum number of attempts to make if a request times out. Default values that are set in knackpy.api.request. Defaults to 5. timeout int, optional - Number of seconds to wait before a Knack API request times out. Further reading: Requests docs.  Returns:\n dict - The updated or newly created Knack record data, or, if deleting a record: {\u0026quot;delete\u0026quot;: true}  upload #  upload(*, app_id: str, api_key: str, obj: str, field: str, path: str, asset_type: str, record_id: str = None, slug: str = None, max_attempts: int = 5, timeout: int = 30) Upload a file or image to Knack. This is a two-step process:\n Upload file asset to Knack storage Create/update a record that links to the file in storage  Knack docs: https://www.knack.com/developer-documentation/`file`-image-uploads\nArguments:\n app_id str - Knack application ID # noqa:E501 string. api_key str - Knack API key. obj str - The Knack object key which holds the record data. field str - The knack field key of the field you\u0026rsquo;re uploading into. path str - The path to the file to be uploaded. asset_type str - The type of Knack field you\u0026rsquo;re uploading to. Must be file or image. record_id str, optional - The knack record ID to which the upload will be attached. If None, will create a new record. Otherwise will update an existing record. slug str, optional - Your organization\u0026rsquo;s slug (aka, subdomain). As found in your app metadata under accounts/slug. max_attempts int - The maximum number of attempts to make if a request times out. Default values that are set in knackpy.api.request. Defaults to 5. timeout int, optional - Number of seconds to wait before a Knack API request times out. Further reading: Requests docs.  "});index.add({'id':2,'href':'/knackpy/docs/api-reference/app/','title':"App",'section':"API Reference",'content':"knackpy.app #  App Objects #  class App() Knackpy is designed around the App class. It provides helpers for querying and manipulating Knack application data. You should use the App class because:\n It allows you to query obejcts and views by key or name It takes care of localization issues It let\u0026rsquo;s you download and upload files from your app. It does other things, too.  Arguments:\n app_id str - Knack application ID # noqa:E501 string. api_key str, optional, default=None - Knack API key. metadata dict, optional - The Knack app\u0026rsquo;s metadata as a dict. If None it will be fetched on init. You can find your apps metadata here. tzinfo pytz.Timezone, optional - [description]. A pytz.Timezone object. When None, is set automatically based on the app\u0026rsquo;s metadadata. max_attempts int - The maximum number of attempts to make if a request times out. Default values that are set in knackpy.api.request. timeout int, optional - Number of seconds to wait before a Knack API request times out. Further reading: Requests docs.  "});index.add({'id':4,'href':'/knackpy/docs/api-reference/field/','title':"Field",'section':"API Reference",'content':"knackpy.fields #  Field Objects #  class Field(object) A container for a single column of Knack data. This is the lowest-level container in the API. The hieracrchy being: App \u0026gt; Records \u0026gt; Record \u0026gt; Field. Typically you would not construct this class directly, but instead an App, which will generate Fields via App.records().\nMore specifically, the API is designed so that you would typically interface with a Field instance through the records.Record class. That class operates on Fields by returning their values through Record[] or Record[].\nBut it\u0026rsquo;s fine to work directly with fields:\n field.value: the unformatted input value field.key: the knack field key field.name: the knack field name  And the method of interest here is .format(), which returns the humanized value.\nArguments:\n field_def knackpy.fields.FieldDef - A knackpy FieldDef class object value object - Anything, really. timezone [pytz.timezone] - A pytz timezone object.  "});index.add({'id':5,'href':'/knackpy/docs/api-reference/record/','title':"Record",'section':"API Reference",'content':"knackpy.record #  Record Objects #  class Record(MutableMapping) A dict-like object for storing record data.\n"});index.add({'id':6,'href':'/knackpy/docs/user-guide/','title':"User Guide",'section':"Docs",'content':"Knackpy #  Knackpy is a Python client for interacting with Knack applications.\nHere\u0026rsquo;s the complete documentation.\nInstallation #  Knackpy requires Python v3.6+. To use the development version Knackpy v1.0, install with:\n$ pip install knackpy-dev Quick Start #  \u0026gt;\u0026gt;\u0026gt; import knackpy # basic app construction \u0026gt;\u0026gt;\u0026gt; app = knackpy.App(app_id=\u0026#34;myappid\u0026#34;, api_key=\u0026#34;myverysecretapikey\u0026#34;) # fetch all records from \u0026#39;object_1\u0026#39; \u0026gt;\u0026gt;\u0026gt; records = app.get(\u0026#34;object_1\u0026#34;) # get the formatted keys/values of each record \u0026gt;\u0026gt;\u0026gt; records_formatted = [record.format() for record in records] # access a record property by name \u0026gt;\u0026gt;\u0026gt; customer_address = records[0][\u0026#34;Customer Address\u0026#34;] # create a record \u0026gt;\u0026gt;\u0026gt; data = {\u0026#34;field_1\u0026#34;: \u0026#34;pizza\u0026#34;} \u0026gt;\u0026gt;\u0026gt; record = app.record(method=\u0026#34;create\u0026#34;, data=data, obj=\u0026#34;object_1\u0026#34;) # download files from an object or view \u0026gt;\u0026gt;\u0026gt; app.download( ... container=\u0026#34;object_1\u0026#34;, ... field=\u0026#34;field_1\u0026#34;, ... out_dir=\u0026#34;_downloads\u0026#34; ... ) # upload a file and attach it to a record \u0026gt;\u0026gt;\u0026gt; app.upload( ... container=\u0026#34;object_1\u0026#34;, # must be an object key or name ... field=\u0026#34;field_3\u0026#34;, ... path=\u0026#34;file.jpg\u0026#34;, ... asset_type=\u0026#34;file\u0026#34;, # must be \u0026#39;file\u0026#39; or \u0026#39;image\u0026#39;, depending on field type ... record_id=\u0026#34;5d7968c8092e7f00106c6399\u0026#34; ... ) Working with Apps #  Knackpy is designed around the App class. It provides helpers for querying and manipulating Knack application data. You should use the App class because:\n It allows you to query obejcts and views by key or name It takes care of localization issues It let\u0026rsquo;s you download and upload files from your app. It does other things, too.  To create an App instance, the bare minimum you need to provide is your application ID.\nIf you construct an App instance without providing an API key, you will only be able to fetch records from publicly-availble views.\nNote that fetching data from public views is a smart way to avoid hitting your API limit.\n# basic app construction with api key \u0026gt;\u0026gt;\u0026gt; import knackpy \u0026gt;\u0026gt;\u0026gt; app = knackpy.App(app_id=\u0026#34;myappid\u0026#34;, api_key=\u0026#34;myverysecretapikey\u0026#34;) Getting Records #  Use App.get() to fetch records from a Knack application. Container identifiers can be supplied as a key (object_1, view_1) or a name (my_exciting_object, My Exciting View).\n# fetch all records from object_1 \u0026gt;\u0026gt;\u0026gt; records = app.get(\u0026#34;object_1\u0026#34;) # or # fetch all records from view named \u0026#34;My Exciting View\u0026#34; \u0026gt;\u0026gt;\u0026gt; records = app.get(\u0026#34;My Exciting View\u0026#34;) Be Careful When Using Named References Namespace conflicts are highly likely when fetching by name, because Knack uses object names as the default name for views. If you attempt to query your application by a name that exists as both an object and a view, Knackpy will raise a ValueError.  You can resuse the same App instance to fetch records from other objects and views.\n\u0026gt;\u0026gt;\u0026gt; app.get(\u0026#34;my_exciting_object\u0026#34;) \u0026gt;\u0026gt;\u0026gt; app.get(\u0026#34;my_boring_object\u0026#34;) \u0026gt;\u0026gt;\u0026gt; app.get(\u0026#34;view_1\u0026#34;) Omitting the Container Name If you\u0026rsquo;ve only fetched one container, you can omit the container name when accessing your records. This is helpful during development, but for readability we suggest you avoid this practice in production code.  \u0026gt;\u0026gt;\u0026gt; records = app.get(\u0026#34;My Exciting View\u0026#34;) # you can omit the container name if you want to access your records again \u0026gt;\u0026gt;\u0026gt; same_records_without_accessor = app.get() You can refine your record requests by specififying a record_limit, filters, and timeout. See the module documentaiton for details.\n\u0026gt;\u0026gt;\u0026gt; filters = { \u0026#34;match\u0026#34;: \u0026#34;or\u0026#34;, \u0026#34;rules\u0026#34;: [ {\u0026#34;field\u0026#34;: \u0026#34;field_1\u0026#34;, \u0026#34;operator\u0026#34;: \u0026#34;is\u0026#34;, \u0026#34;value\u0026#34;: 1}, {\u0026#34;field\u0026#34;: \u0026#34;field_2\u0026#34;, \u0026#34;operator\u0026#34;: \u0026#34;is\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Pizza\u0026#34;}, ], } \u0026gt;\u0026gt;\u0026gt; records = app.get(\u0026#34;object_1\u0026#34;, record_limit=10, filters=filters) Creating, Updating, and Deleting Records #  Create a record.\n\u0026gt;\u0026gt;\u0026gt; app = knackpy.App(app_id=\u0026#34;myappid\u0026#34;, api_key=\u0026#34;myverysecretapikey\u0026#34;) \u0026gt;\u0026gt;\u0026gt; data = {\u0026#34;field_1\u0026#34;: \u0026#34;pizza\u0026#34;} \u0026gt;\u0026gt;\u0026gt; record = app.record(method=\u0026#34;create\u0026#34;, data=data, obj=\u0026#34;object_1\u0026#34;) Update a record.\n\u0026gt;\u0026gt;\u0026gt; app = knackpy.App(app_id=\u0026#34;myappid\u0026#34;, api_key=\u0026#34;myverysecretapikey\u0026#34;) \u0026gt;\u0026gt;\u0026gt; record = app.get(\u0026#34;object_1\u0026#34;)[0] \u0026gt;\u0026gt;\u0026gt; data = dict(record) \u0026gt;\u0026gt;\u0026gt; data[\u0026#34;field_1\u0026#34;] = \u0026#34;new value\u0026#34; \u0026gt;\u0026gt;\u0026gt; record = app.record(method=\u0026#34;update\u0026#34;, data=data, obj=\u0026#34;object_1\u0026#34;) Delete a record.\n\u0026gt;\u0026gt;\u0026gt; response = app.record(method=\u0026#34;delete\u0026#34;, data={\u0026#34;id\u0026#34;: \u0026#34;abc123xyz789\u0026#34;}, obj=\u0026#34;object_1\u0026#34;) # response == {\u0026#34;delete\u0026#34;: True} Download Files #  Download files from an object or view.\n  container (str): The name or key of the object or view from which files will be downloaded.\n  field (str): The field key of the file or image field to be downloaded.\n  out_dir (str, optional): Relative path to the directory to which files will be written. Defaults to \u0026ldquo;_downloads\u0026rdquo;.\n  label_keys (list, optional): A list of field keys whose values will be prepended to the attachment filename, separated by an underscore.\n  \u0026gt;\u0026gt;\u0026gt; app.download( ... container=\u0026#34;object_1\u0026#34;, ... field=\u0026#34;field_1\u0026#34;, ... out_dir=\u0026#34;_downloads\u0026#34;, ... label_keys=\u0026#34;field_2\u0026#34; ... ) Upload Files #  Upload a file and attach it to a Knack record.\n\u0026gt;\u0026gt;\u0026gt; res = app.upload( ... container=\u0026#34;object_1\u0026#34;, # must be an object key or name ... field=\u0026#34;field_3\u0026#34;, ... path=\u0026#34;file.jpg\u0026#34;, ... asset_type=\u0026#34;file\u0026#34;, # must be \u0026#39;file\u0026#39; or \u0026#39;image\u0026#39;, depending on field type ... record_id=\u0026#34;5d7968c8092e7f00106c6399\u0026#34; ... ) Advanced App Usage #  Raw record data is available at App.data. You can use this property to check the readily available data in your App instance.\n\u0026gt;\u0026gt;\u0026gt; app.data.keys() [\u0026#34;object_1\u0026#34;, \u0026#34;object_2\u0026#34;, \u0026#34;view_1\u0026#34;] References to all available endpoints are stored at App.containers. This is handy if you want to check the name of a container, or its key:\n\u0026gt;\u0026gt;\u0026gt; app.containers [ Container(obj=\u0026#39;object_1\u0026#39;, view=None, scene=None, name=\u0026#39;my_boring_object\u0026#39;), Container(obj=\u0026#39;object_2\u0026#39;, view=None, scene=None, name=\u0026#39;my_exciting_object\u0026#39;), Container(obj=None, view=\u0026#39;view_1\u0026#39;, scene=\u0026#39;scene_1\u0026#39;, name=\u0026#39;My Exciting View\u0026#39;), ] You can avoid an API call by providing your own Knack metadata when creating an App instance (unclear if metadata requests count against API limits)\n\u0026gt;\u0026gt;\u0026gt; import json # get your app\u0026#39;s metadata here: https://loader.knack.com/v1/applications/\u0026lt;app_id:str\u0026gt;\u0026#34; \u0026gt;\u0026gt;\u0026gt; with open(\u0026#34;my_metadata.json\u0026#34;, \u0026#34;r\u0026#34;) as fin: ... metadata = json.loads(fin.read()) \u0026gt;\u0026gt; app = knackpy.App(app_id, metadata=metadata) You can side-load record data into your your app as well. Note that you must assign your data to a valid key that exists in your app.\n\u0026gt;\u0026gt;\u0026gt; with open(\u0026#34;my_knack_data.json\u0026#34;, \u0026#34;r\u0026#34;) as fin: ... data = { \u0026#34;object_3\u0026#34;: json.loads(fin.read()) } \u0026gt;\u0026gt; app.data = data \u0026gt;\u0026gt; records = app.get(\u0026#34;object_3\u0026#34;) You can use knackpy.get() to fetch \u0026ldquo;raw\u0026rdquo; data from your Knack app. Be aware that raw Knack timestamps are problematic. See the Records documentation.\nOther App Methods #  Display summary metrics about the app.\n\u0026gt;\u0026gt;\u0026gt; app.info() {\u0026#39;objects\u0026#39;: 10, \u0026#39;scenes\u0026#39;: 4, \u0026#39;records\u0026#39;: 6786, \u0026#39;size\u0026#39;: \u0026#39;25.47mb\u0026#39;} Write a container to CSV. Be aware that destination files will be overwritten, if they exist.\n\u0026gt;\u0026gt;\u0026gt; app.to_csv(\u0026#34;my exciting view\u0026#34;, out_dir=\u0026#34;data\u0026#34;) Working with Record Objects #  Record objects are dict-like containers for Knack record data. Note that all timestamps have been correctly set to unix time.\nYou can access a record value like you would a dict, using the field key or field name.\n\u0026gt;\u0026gt;\u0026gt; record = app.get(\u0026#34;object_1\u0026#34;)[0] # access a value via field key \u0026gt;\u0026gt;\u0026gt; record[\u0026#34;field_22\u0026#34;] {\u0026#34;city\u0026#34;: \u0026#34;Austin\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;TX\u0026#34;, \u0026#34;street\u0026#34;: \u0026#34;8700 Cameron Rd\u0026#34;, \u0026#34;street2\u0026#34;: \u0026#34;Suite 1\u0026#34;, \u0026#34;zip\u0026#34;: \u0026#34;78754\u0026#34;} # access a value via field name \u0026gt;\u0026gt;\u0026gt; record[\u0026#34;Customer Address\u0026#34;] {\u0026#34;city\u0026#34;: \u0026#34;Austin\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;TX\u0026#34;, \u0026#34;street\u0026#34;: \u0026#34;8700 Cameron Rd\u0026#34;, \u0026#34;street2\u0026#34;: \u0026#34;Suite 1\u0026#34;, \u0026#34;zip\u0026#34;: \u0026#34;78754\u0026#34;} Formatting Records #  Format the keys and/or values of a record.\n# format keys and values \u0026gt;\u0026gt;\u0026gt; formatted_record = record.format() { \u0026#34;id\u0026#34;: \u0026#34;abc123xyz789\u0026#34;, \u0026#34;Customer Address\u0026#34;: \u0026#34;8700 Cameron Rd, Austin, TX, 78754\u0026#34; } # only format the keys \u0026gt;\u0026gt;\u0026gt; formatted_keys = record.format(values=False) { \u0026#34;id\u0026#34;: \u0026#34;abc123xyz789\u0026#34;, \u0026#34;Customer Address\u0026#34;: {\u0026#34;city\u0026#34;: \u0026#34;Austin\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;TX\u0026#34;, \u0026#34;street\u0026#34;: \u0026#34;8700 Cameron Rd\u0026#34;, \u0026#34;street2\u0026#34;: \u0026#34;Suite 1\u0026#34;, \u0026#34;zip\u0026#34;: \u0026#34;78754\u0026#34;}} # only format the values \u0026gt;\u0026gt;\u0026gt; formatted_values = record.format(keys=False) { \u0026#34;id\u0026#34;: \u0026#34;abc123xyz789\u0026#34;, \u0026#34;field_22\u0026#34;: \u0026#34;8700 Cameron Rd, Austin, TX, 78754\u0026#34; } # format specific keys and values \u0026gt;\u0026gt;\u0026gt; formatted_values = record.format(keys=[\u0026#34;field_22\u0026#34;], values=[\u0026#34;field_22\u0026#34;]) { \u0026#34;id\u0026#34;: \u0026#34;abc123xyz789\u0026#34;, \u0026#34;Customer Address\u0026#34;: \u0026#34;8700 Cameron Rd, Austin, TX, 78754\u0026#34; } Although a Record object looks like a dict, it contains Field objects (TODO: link to docs). If you want to convert a Record object into a plain-old dict, use the dict() built-in.\n\u0026gt;\u0026gt;\u0026gt; record = app.get(\u0026#34;object_1\u0026#34;)[0] \u0026gt;\u0026gt;\u0026gt; data = dict(record) Dict-like Record methods (Items, Keys, and Names) #   Record.items(): returns a list of the knackpy Field objects contained within the Record. Record.keys(): returns a list (not a view) of the record\u0026rsquo;s field keys. Record.names(): returns a list of the record\u0026rsquo;s field names.  Records may look raw, but any timestamps have been corrected to real unix time. If you want the raw, untouched data, use the Record.raw property.\n{{ \u0026lt; /hint \u0026gt; }}\nAccessing the API Directly # This is equivalent to exporting records in JSON format from the Knack Builder \u0026gt;\u0026gt;\u0026gt; import knackpy \u0026gt;\u0026gt;\u0026gt; data = knackpy.get( ... app_id=\u0026#34;myappid\u0026#34;, ... api_key=\u0026#34;myverysecretapikey\u0026#34;, ... obj=\u0026#34;object_1\u0026#34;, ... record_limit=None, ... timeout=30 ... ) Crud Operations What\u0026rsquo;s New in v1.0  The Knack class is now App. Fetch records using object/view names No more rows-per-page or page count limiting; just set a record_limit. App summary stats:  \u0026gt;\u0026gt;\u0026gt; app.info() {\u0026#39;objects\u0026#39;: 10, \u0026#39;scenes\u0026#39;: 4, \u0026#39;records\u0026#39;: 6786, \u0026#39;size\u0026#39;: \u0026#39;25.47mb\u0026#39;}  Pythonic use of exceptions, warnings, and logging. Automatic localization (no need to set TZ info) \u0026ldquo;Raw\u0026rdquo; data is available with timestamp corrections Reduce API calls with metadata and/or record side-loading Null values are consistently returned as NoneType's  Issues and Contributions Issues and pull requests are welcome. Know that your contributions are donated to the public domain.\nTimestamps and Localization Although the Knack API returns timestamp values as Unix timestamps in millesconds, these raw values represent millisecond timestamps in your localized timezone. For example a Knack timestamp value of 1578254700000 represents Sunday, January 5, 2020 8:05:00 PM local time.\nTo address this, the App class converts Knack timestamps into real (UTC-based) unix timestamps. Timestamps are corrected by referencing the timezone info in your apps metadata. You can manually override your app\u0026rsquo;s timezone information by passing an IANA-compliant timezone string to your App instance, like so:\n\u0026gt;\u0026gt;\u0026gt; app = knackpy.App(app_id=\u0026#34;myappid\u0026#34;, api_key=\u0026#34;myverysecretapikey\u0026#34;, tzinfo=\u0026#34;US/Eastern\u0026#34;) If you\u0026rsquo;d like to access your raw, uncorrected records, they can be found at App.data[\u0026lt;container_name:str\u0026gt;].\nNote also that Record objects return corrected timestamps via Record.raw and Record.format(). So,\n\u0026gt;\u0026gt;\u0026gt; app = knackpy.App(app_id=\u0026#34;myappid\u0026#34;, api_key=\u0026#34;myverysecretapikey\u0026#34;, tzinfo=\u0026#34;US/Eastern\u0026#34;) # yields raw records with corrected millisecond timestamps \u0026gt;\u0026gt;\u0026gt; records_raw = [record.raw for record in app.get(\u0026#34;object_3\u0026#34;)] # yields corrected timestamps as ISO-8601 strings \u0026gt;\u0026gt;\u0026gt; records_formatted = [record.format() for record in app.get(\u0026#34;object_3\u0026#34;)] Exceptions Knackpy uses Python\u0026rsquo;s built-in exceptions, as well as Requests\u0026rsquo;s exceptions when interacting with the Knack API.\nIf you need to inspect an API exception (for example to see the text content of the response), you can access the Response object by handling the exception like so:\n\u0026gt;\u0026gt;\u0026gt; app = knackpy.App(api_key=\u0026#34;myappid\u0026#34;) # raises HTTPError. You cannot request object records without supplying an API key \u0026gt;\u0026gt;\u0026gt; try: ... records = app.get(\u0026#34;object_1\u0026#34;) ... except HTTPError as e: ... print(e.response.text) ... raise e # \u0026#39;Unauthorized Object Access\u0026#39;   "});})();