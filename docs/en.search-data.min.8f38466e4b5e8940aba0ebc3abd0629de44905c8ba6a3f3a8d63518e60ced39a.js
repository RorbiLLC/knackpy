'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/knackpy/docs/api-reference/api/','title':"API",'section':"API Reference",'content':"knackpy.api #  get #  get(*, app_id: str, api_key: str = None, slug: str = None, obj: str = None, scene: str = None, view: str = None, record_limit: int = None, filters: dict = None, max_attempts: int = 5, timeout: int = 30) -\u0026gt; [list, requests.Response] Get records from a knack object or view. This is the raw stuff with incorrect timestamps!\nArguments:\n app_id str - [description] api_key str, optional - [description]. Defaults to None. slug str, optional - Your organization\u0026rsquo;s slug (aka, subdomain). As found in your app metadata under accounts.slug. obj str, optional - [description]. Defaults to None. scene str, optional - [description]. Defaults to None. view str, optional - [description]. Defaults to None. max_attempts int, optional - [description]. Defaults to 5. record_limit int, optional - [description]. Defaults to None (which is handled as infinity). timeout int, optional - [description]. Defaults to 30. filters [list, dict], optional - Knack record filter dict or list. Defaults to None.  Returns:\n list - Knack records.  get_metadata #  get_metadata(*, app_id: str, slug: str = None, timeout: int = 30) -\u0026gt; dict Fetch Knack application metadata. You can find your app\u0026rsquo;s metadata at: https://api.knack.com/v1/applications/\u0026lt;app_id:str\u0026gt;.\nArguments:\n app_id str - A Knack application ID. slug str, optional - Your organization\u0026rsquo;s slug (aka, subdomain). As found in your app metadata under accounts/slug.  Returns:\n dict - A dictionary of Knack application metadata.  record #  record(*, app_id: str, api_key: str, data: dict, method: str, obj: str, slug: str = None, max_attempts: int = 5, timeout: int = 30) Create, update, or delete a Knack record.\nArguments:\n app_id str - Knack application ID # noqa:E501 string. api_key str - Knack API key. slug str, optional - Your organization\u0026rsquo;s slug (aka, subdomain). As found in your app metadata under accounts/slug. data dict - The Knack record data payload. method str - Choose from create, update, or delete. obj str, optional - The Knack object key which holds the record data. max_attempts int - The maximum number of attempts to make if a request times out. Default values that are set in knackpy.api.request. Defaults to 5. timeout int, optional - Number of seconds to wait before a Knack API request times out. Further reading: Requests docs.  Returns:\n dict - The updated or newly created Knack record data, or, if deleting a record: {\u0026quot;delete\u0026quot;: true}  upload #  upload(*, app_id: str, api_key: str, obj: str, field: str, path: str, asset_type: str, record_id: str = None, slug: str = None, max_attempts: int = 5, timeout: int = 30) Upload a file or image to Knack. This is a two-step process:\n Upload file asset to Knack storage Create/update a record that links to the file in storage  Knack docs: https://www.knack.com/developer-documentation/`file`-image-uploads\nArguments:\n app_id str - Knack application ID # noqa:E501 string. api_key str - Knack API key. obj str - The Knack object key which holds the record data. field str - The knack field key of the field you\u0026rsquo;re uploading into. path str - The path to the file to be uploaded. asset_type str - The type of Knack field you\u0026rsquo;re uploading to. Must be file or image. record_id str, optional - The knack record ID to which the upload will be attached. If None, will create a new record. Otherwise will update an existing record. slug str, optional - Your organization\u0026rsquo;s slug (aka, subdomain). As found in your app metadata under accounts/slug. max_attempts int - The maximum number of attempts to make if a request times out. Default values that are set in knackpy.api.request. Defaults to 5. timeout int, optional - Number of seconds to wait before a Knack API request times out. Further reading: Requests docs.  "});index.add({'id':1,'href':'/knackpy/docs/api-reference/','title':"API Reference",'section':"Docs",'content':"Knackpy API Reference #  To understand knackpy\u0026rsquo;s design, it\u0026rsquo;s helpful to think of it in terms of two entry points:\n Api: Contains core functions for over-the-wire interactions with the Knack API, as well as helpers for pagination and re-trying on request failures. App: The highest-level container for getting and interacting with Knack records.  The other the knackpy classes act as a hierarchy that are constructed through a chain of side-effects originating from App objects.\n Record: A dict-like container for Field objects which supplies helpers for accesing and formatting fields. Field: A container for a single Knack key/value, with helpers for formatting. FieldDef: Stores field metadata (type, formatting method, parent objects/views)  "});index.add({'id':2,'href':'/knackpy/docs/api-reference/app/','title':"App",'section':"API Reference",'content':"knackpy.app #  App Objects #  class App() Knackpy is designed around the App class. It provides helpers for querying and manipulating Knack application data. You should use the App class because:\n It allows you to query obejcts and views by key or name It takes care of localization issues # noqa:E501 It let\u0026rsquo;s you download and upload files from your app. It does other things, too.  Arguments:\n app_id str - Knack application ID # noqa:E501 string. api_key str, optional, default=None - Knack API key. metadata dict, optional - The Knack app\u0026rsquo;s metadata as a dict. If None it will be fetched on init. You can find your apps metadata here. tzinfo pytz.Timezone, optional - [description]. A pytz.Timezone object. When None, is set automatically based on the app\u0026rsquo;s metadadata. max_attempts int - The maximum number of attempts to make if a request times out. Default values that are set in knackpy.api.request. timeout int, optional - Number of seconds to wait before a Knack API request times out. Further reading: Requests docs.  info #  | info() Returns a dict of basic app information:\n Number of objects Number of scenes Number of records Number total file size  get #  | get(identifier: str = None, refresh: bool = False, record_limit: int = None, filters: typing.Union[dict, list] = None, generate=False) Get records from a knack object or view.\nNote that we accept the request params record_limit and filters here because the user would presumably want to set these on a per-object/view basis. They are not stored in state. Whereas max_attempts and timeout are set on App construction and persist in App state.\nArguments:\n identifier _str, optional*_ - an object or view key or name string that exists in the app. If None is provided and only one container has been fetched, will return records from that container. refresh bool, optional - Force the re-querying of data from Knack API. Defaults to False. record_limit int - the maximum number of records to retrieve. If None, will return all records. filters dict or list, optional - A dict or of Knack API filiters. See - https://www.knack.com/developer-documentation/`filters`. generate bool, optional - If True, will return a generator which yields knacky.Record objects instead of return a list of of them.  Returns:\nA generator which yields knackpy Record objects.\nto_csv #  | to_csv(identifier: str, *, out_dir: str = \u0026#34;_csv\u0026#34;, delimiter=\u0026#34;,\u0026#34;, record_limit: int = None, filters: typing.Union[dict, list] = None) -\u0026gt; None Write formatted Knack records to CSV.\nArguments:\n identifier str - an object or view key or name string that exists in the app. out_dir str, optional - Relative path to the directory to which files will be written. Defaults to \u0026ldquo;_csv\u0026rdquo;. delimiter str, optional - [description]. Defaults to \u0026ldquo;,\u0026rdquo;. record_limit int - the maximum number of records to retrieve. If None, will return all records. filters dict or list, optional - A dict or of Knack API filiters. See - https://www.knack.com/developer-documentation/`filters`.  download #  | download(*, container: str, field: str, out_dir: str = \u0026#34;_downloads\u0026#34;, label_keys: list = None) Download files and images from Knack records.\nArguments:\n container str - The name or key of the object from which files will be downloaded. out_dir str, optional - Relative path to the directory to which files will be written. Defaults to \u0026ldquo;_downloads\u0026rdquo;. field str - The Knack field key of the file or image field to be downloaded. label_keys list, optional - A list of field keys whose values will be prepended to the attachment filename, separated by an underscore.  Returns:\n [int] - Count of files downloaded.  record #  | record(*, data: dict, method: str, obj: str) Create, update, or delete a Knack record.\nArguments:\n data dict - The Knack record data payload. method str - Choose from create, update, or delete. obj str, optional - The Knack object key or name which holds the record data.  Returns:\n dict - The updated or newly created Knack record data, or, if deleting a record - {\u0026quot;delete\u0026quot;: true}  upload #  | upload(*, container: str, field: str, path: str, asset_type: str, record_id: str = None) Upload a file or image to Knack. This is a two-step process:\n Upload file asset to Knack storage Create/update a record that links to the file in storage  Knack docs: https://www.knack.com/developer-documentation/`file`-image-uploads\nArguments:\n container str - The name or key of the object from which files will be downloaded. field str - The knack field key of the field you\u0026rsquo;re uploading into. path str - The path to the file to be uploaded. asset_type str - The type of Knack field you\u0026rsquo;re uploading to. Must be file or image. record_id str, optional - The knack record ID to which the upload will be attached. If None, will create a new record. Otherwise will update an existing record.  "});index.add({'id':3,'href':'/knackpy/docs/developer-guide/','title':"Developer Guide",'section':"Docs",'content':"Developer Guide #  Issues and pull requests are welcome. Know that your contributions are donated to the public domain.\nEnvironment Setup #  Python release candidates are tested against Python 3.6+, so your safest bet when developing is to use v3.6. However, we encourage you to develop in the most current stable release of Python 3 so that you can help us identify potential future compatibility issues.\nInstall the development environment requirements from requirements/dev.txt. This will install the test suite and documentation tooling.\n$ pip install -r requirements/dev.txt Clone the Knackpy repo and create a new branch from the dev branch. Use the -e flag to install in development mode:\n$ pip install -e knackpy Tests #  We test with pytest, coverage, and pytest-env.\nKnacky Development Knack Application #  Tests for app.py and api.py are dependendent on a City of Austin-owned Knack application which we rely on for over-the-wire API tests. If you work for the City of Austin Transportation Department, the credentials for this app are in our password store, and the app is called \u0026ldquo;Knackpy Development\u0026rdquo;.\nAny modifications you make to the Knackpy Development app may impact tests. You should carefully review our tests/ before you modify anything in the development app.\nSome tests rely on static json data stored in the tests directory. After modifying the app, you must refresh the static data by replacing tests/_metadata.json with the most current app metadata, as well as tests._all_fields.json with records exported from the all_fields object in the Knack app.\nWriting Tests #  Ideally, you would add tests for your code to the appropriate test collection in the tests/ directory. If you don\u0026rsquo;t have access to our development Knack application, please at least write an example test in your pull request.\nRunning Tests #  You can run ad-hoc tests with:\n$ coverage run -m pytest -c path/to/your/tests Before you can run the entire test suite, you\u0026rsquo;ll need to create a pytest.ini config with the appropriate environmental variables. You can model it after this example.\nTo run the test suite from pytest.ini, use: $ coverage run -m pytest -c tests/pytest.ini -x.\nAfter running the tests, you can use $ coverage html to generate HTML documentation of code coverage.\nYou can update the coverage badge image with:\n$ coverage-badge -f -o coverage.svg Linting and Formatting #  We useblack for formatting and flake8 for formatting and linting code.\nUse flake8\u0026rsquo;s --max-line-length param so that the linter matches black\u0026rsquo;s line length opinion:\n$ flake8 --max-line-length=88 Documentation #  Use Google docstring format and type hints.\nWe use pydoc-markdown to generate the documentation HTML. You\u0026rsquo;ll need to install Hugo in order to build/serve the documentation site. See also the pydoc-markdown.yml config.\nRebuild and commit the documentation HTML whenever you update module docstrings or the user guide.\n# build html content $ pydoc-markdown --build --site-dir docs # or build and serve locally $ pydoc-markdown --server Automated Tests and Deployment #  We use Github Actions to test Knackpy builds and to publish to PyPI. The workflows are defined in .github/workflows.\nAny commit/merge to the dev branch will trigger a PyPI publication to the knackpy-dev package. Any release on the master branch will trigger publication to the knackpy package on PyPI. Note that PyPI publications will fail if don\u0026rsquo;t bump the version number in setup.py.\n"});index.add({'id':5,'href':'/knackpy/docs/api-reference/fields/','title':"Fields",'section':"API Reference",'content':"knackpy.fields #  FieldDef Objects #  class FieldDef() Knack field defintion wrapper\nField Objects #  class Field(object) A container for a single column of Knack data. This is the lowest-level container in the API. The hieracrchy being: App \u0026gt; Records \u0026gt; Record \u0026gt; Field. Typically you would not construct this class directly, but instead an App, which will generate Fields via App.records().\nMore specifically, the API is designed so that you would typically interface with a Field instance through the records.Record class. That class operates on Fields by returning their values through Record[] or Record[].\nBut it\u0026rsquo;s fine to work directly with fields:\n field.value: the unformatted input value field.formatted: the formatted value field.key: the knack field key field.name: the knack field name  Arguments:\n field_def knackpy.fields.FieldDef - A knackpy FieldDef class object value object - Anything, really. timezone [pytz.timezone] - A pytz timezone object. knack_formatted_value str, optional - There a fiew fields where it\u0026rsquo;s easier to use knack\u0026rsquo;s formatted value as a starting point, rather than the raw value. E.g. timer and name. In those cases, we assign that value here and pass it on to the self.formatter() function for further formatting.  "});index.add({'id':6,'href':'/knackpy/docs/api-reference/record/','title':"Record",'section':"API Reference",'content':"knackpy.record #  Record Objects #  class Record(MutableMapping) A dict-like object for storing record data.\n__getitem__ #  | __getitem__(client_key) Return the field whose key or name matches the client-provided value.\nArguments:\n client_key str - A field key (e.g., \u0026ldquo;field_99\u0026rdquo;) or field name.  Returns:\n object - The field\u0026rsquo;s value (dict, list, str, int, whatever Knack has in store for you.)  __setitem__ #  | __setitem__(key, value) Bad things will happen if you re-assign record values to anything other than a field class. This is not immediately obvious, because you can assign values to the record without issue, but some operations will fail after assignment of a non-Field value. e.g., .format() and dict().\nAll that to say, we set immutable = True after init, and further attempts to setitem will raise a TypeError.\nRaises:\n TypeError - \u0026lsquo;Record\u0026rsquo; object does not support item assignment.  format #  | format(keys: Union[list, bool] = True, values: Union[list, bool] = True) Returns the record as a dict.\nArguments:\n keys bool or list, optional - If the keys should be formatted, or a list of field keys specifying the keys to be formatted. values bool or list, optional - If values should be formatted, or a list of field keys specifying the values to be formatted  Returns:\n dict - A dict of the record values with formatted (aka, humaized) keys and/or values.  "});index.add({'id':7,'href':'/knackpy/docs/user-guide/','title':"User Guide",'section':"Docs",'content':"Knackpy #  Knackpy is a Python client for interacting with Knack applications.\nHere\u0026rsquo;s the complete documentation.\nInstallation #  $ pip install knackpy Quick Start #  \u0026gt;\u0026gt;\u0026gt; import knackpy # basic app construction \u0026gt;\u0026gt;\u0026gt; app = knackpy.App(app_id=\u0026#34;myappid\u0026#34;, api_key=\u0026#34;myverysecretapikey\u0026#34;) # fetch all records from \u0026#39;object_1\u0026#39; \u0026gt;\u0026gt;\u0026gt; records = app.get(\u0026#34;object_1\u0026#34;) # get the formatted keys/values of each record \u0026gt;\u0026gt;\u0026gt; records_formatted = [record.format() for record in records] # access a record property by name \u0026gt;\u0026gt;\u0026gt; customer_address = records[0][\u0026#34;Customer Address\u0026#34;] # create a record \u0026gt;\u0026gt;\u0026gt; data = {\u0026#34;field_1\u0026#34;: \u0026#34;pizza\u0026#34;} \u0026gt;\u0026gt;\u0026gt; record = app.record(method=\u0026#34;create\u0026#34;, data=data, obj=\u0026#34;object_1\u0026#34;) # download files from an object or view \u0026gt;\u0026gt;\u0026gt; app.download( ... container=\u0026#34;object_1\u0026#34;, ... field=\u0026#34;field_1\u0026#34;, ... out_dir=\u0026#34;_downloads\u0026#34; ... ) # upload a file and attach it to a record \u0026gt;\u0026gt;\u0026gt; app.upload( ... container=\u0026#34;object_1\u0026#34;, # must be an object key or name ... field=\u0026#34;field_3\u0026#34;, ... path=\u0026#34;file.jpg\u0026#34;, ... asset_type=\u0026#34;file\u0026#34;, # must be \u0026#39;file\u0026#39; or \u0026#39;image\u0026#39;, depending on field type ... record_id=\u0026#34;5d7968c8092e7f00106c6399\u0026#34; ... ) Working with Apps #  Knackpy is designed around the App class. It provides helpers for querying and manipulating Knack application data. You should use the App class because:\n It allows you to query obejcts and views by key or name It takes care of localization issues It let\u0026rsquo;s you download and upload files from your app. It does other things, too.  To create an App instance, the bare minimum you need to provide is your application ID.\nIf you construct an App instance without providing an API key, you will only be able to fetch records from publicly-availble views.\nNote that fetching data from public views is a smart way to avoid hitting your API limit.\n# basic app construction with api key \u0026gt;\u0026gt;\u0026gt; import knackpy \u0026gt;\u0026gt;\u0026gt; app = knackpy.App(app_id=\u0026#34;myappid\u0026#34;, api_key=\u0026#34;myverysecretapikey\u0026#34;) Getting Records #  Use App.get() to fetch records from a Knack application. Container identifiers can be supplied as a key (object_1, view_1) or a name (my_exciting_object, My Exciting View).\n# fetch all records from object_1 \u0026gt;\u0026gt;\u0026gt; records = app.get(\u0026#34;object_1\u0026#34;) # or # fetch all records from view named \u0026#34;My Exciting View\u0026#34; \u0026gt;\u0026gt;\u0026gt; records = app.get(\u0026#34;My Exciting View\u0026#34;) Be Careful When Using Named References Namespace conflicts are highly likely when fetching by name, because Knack uses object names as the default name for views. If you attempt to query your application by a name that exists as both an object and a view, Knackpy will raise a ValueError.  You can resuse the same App instance to fetch records from other objects and views.\n\u0026gt;\u0026gt;\u0026gt; app.get(\u0026#34;my_exciting_object\u0026#34;) \u0026gt;\u0026gt;\u0026gt; app.get(\u0026#34;my_boring_object\u0026#34;) \u0026gt;\u0026gt;\u0026gt; app.get(\u0026#34;view_1\u0026#34;) Omitting the Container Name If you\u0026rsquo;ve only fetched one container, you can omit the container name when accessing your records. This is helpful during development, but for readability we suggest you avoid this practice in production code.  \u0026gt;\u0026gt;\u0026gt; records = app.get(\u0026#34;My Exciting View\u0026#34;) # you can omit the container name if you want to access your records again \u0026gt;\u0026gt;\u0026gt; same_records_without_accessor = app.get() You can refine your record requests by specififying a record_limit, filters, and timeout. See the module documentaiton for details.\n\u0026gt;\u0026gt;\u0026gt; filters = { \u0026#34;match\u0026#34;: \u0026#34;or\u0026#34;, \u0026#34;rules\u0026#34;: [ {\u0026#34;field\u0026#34;: \u0026#34;field_1\u0026#34;, \u0026#34;operator\u0026#34;: \u0026#34;is\u0026#34;, \u0026#34;value\u0026#34;: 1}, {\u0026#34;field\u0026#34;: \u0026#34;field_2\u0026#34;, \u0026#34;operator\u0026#34;: \u0026#34;is\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Pizza\u0026#34;}, ], } \u0026gt;\u0026gt;\u0026gt; records = app.get(\u0026#34;object_1\u0026#34;, record_limit=10, filters=filters) Creating, Updating, and Deleting Records #  Create a record.\n\u0026gt;\u0026gt;\u0026gt; app = knackpy.App(app_id=\u0026#34;myappid\u0026#34;, api_key=\u0026#34;myverysecretapikey\u0026#34;) \u0026gt;\u0026gt;\u0026gt; data = {\u0026#34;field_1\u0026#34;: \u0026#34;pizza\u0026#34;} \u0026gt;\u0026gt;\u0026gt; record = app.record(method=\u0026#34;create\u0026#34;, data=data, obj=\u0026#34;object_1\u0026#34;) Update a record.\n\u0026gt;\u0026gt;\u0026gt; app = knackpy.App(app_id=\u0026#34;myappid\u0026#34;, api_key=\u0026#34;myverysecretapikey\u0026#34;) \u0026gt;\u0026gt;\u0026gt; record = app.get(\u0026#34;object_1\u0026#34;)[0] \u0026gt;\u0026gt;\u0026gt; data = dict(record) \u0026gt;\u0026gt;\u0026gt; data[\u0026#34;field_1\u0026#34;] = \u0026#34;new value\u0026#34; \u0026gt;\u0026gt;\u0026gt; record = app.record(method=\u0026#34;update\u0026#34;, data=data, obj=\u0026#34;object_1\u0026#34;) Delete a record.\n\u0026gt;\u0026gt;\u0026gt; response = app.record(method=\u0026#34;delete\u0026#34;, data={\u0026#34;id\u0026#34;: \u0026#34;abc123xyz789\u0026#34;}, obj=\u0026#34;object_1\u0026#34;) # response == {\u0026#34;delete\u0026#34;: True} Download Files #  Download files from an object or view.\n  container (str): The name or key of the object or view from which files will be downloaded.\n  field (str): The field key of the file or image field to be downloaded.\n  out_dir (str, optional): Relative path to the directory to which files will be written. Defaults to \u0026ldquo;_downloads\u0026rdquo;.\n  label_keys (list, optional): A list of field keys whose values will be prepended to the attachment filename, separated by an underscore.\n  \u0026gt;\u0026gt;\u0026gt; app.download( ... container=\u0026#34;object_1\u0026#34;, ... field=\u0026#34;field_1\u0026#34;, ... out_dir=\u0026#34;_downloads\u0026#34;, ... label_keys=\u0026#34;field_2\u0026#34; ... ) Upload Files #  Upload a file and attach it to a Knack record.\n\u0026gt;\u0026gt;\u0026gt; res = app.upload( ... container=\u0026#34;object_1\u0026#34;, # must be an object key or name ... field=\u0026#34;field_3\u0026#34;, ... path=\u0026#34;file.jpg\u0026#34;, ... asset_type=\u0026#34;file\u0026#34;, # must be \u0026#39;file\u0026#39; or \u0026#39;image\u0026#39;, depending on field type ... record_id=\u0026#34;5d7968c8092e7f00106c6399\u0026#34; ... ) Advanced App Usage #  Raw record data is available at App.data. You can use this property to check the readily available data in your App instance.\n\u0026gt;\u0026gt;\u0026gt; app.data.keys() [\u0026#34;object_1\u0026#34;, \u0026#34;object_2\u0026#34;, \u0026#34;view_1\u0026#34;] References to all available endpoints are stored at App.containers. This is handy if you want to check the name of a container, or its key:\n\u0026gt;\u0026gt;\u0026gt; app.containers [ Container(obj=\u0026#39;object_1\u0026#39;, view=None, scene=None, name=\u0026#39;my_boring_object\u0026#39;), Container(obj=\u0026#39;object_2\u0026#39;, view=None, scene=None, name=\u0026#39;my_exciting_object\u0026#39;), Container(obj=None, view=\u0026#39;view_1\u0026#39;, scene=\u0026#39;scene_1\u0026#39;, name=\u0026#39;My Exciting View\u0026#39;), ] You can avoid an API call by providing your own Knack metadata when creating an App instance (unclear if metadata requests count against API limits)\n\u0026gt;\u0026gt;\u0026gt; import json # get your app\u0026#39;s metadata here: https://loader.knack.com/v1/applications/\u0026lt;app_id:str\u0026gt;\u0026#34; \u0026gt;\u0026gt;\u0026gt; with open(\u0026#34;my_metadata.json\u0026#34;, \u0026#34;r\u0026#34;) as fin: ... metadata = json.loads(fin.read()) \u0026gt;\u0026gt; app = knackpy.App(app_id, metadata=metadata) You can side-load record data into your your app as well. Note that you must assign your data to a valid key that exists in your app.\n\u0026gt;\u0026gt;\u0026gt; with open(\u0026#34;my_knack_data.json\u0026#34;, \u0026#34;r\u0026#34;) as fin: ... data = { \u0026#34;object_3\u0026#34;: json.loads(fin.read()) } \u0026gt;\u0026gt; app.data = data \u0026gt;\u0026gt; records = app.get(\u0026#34;object_3\u0026#34;) You can use knackpy.get() to fetch \u0026ldquo;raw\u0026rdquo; data from your Knack app. Be aware that raw Knack timestamps are problematic. See the Records documentation.\nOther App Methods #  Display summary metrics about the app.\n\u0026gt;\u0026gt;\u0026gt; app.info() {\u0026#39;objects\u0026#39;: 10, \u0026#39;scenes\u0026#39;: 4, \u0026#39;records\u0026#39;: 6786, \u0026#39;size\u0026#39;: \u0026#39;25.47mb\u0026#39;} Write a container to CSV. Be aware that destination files will be overwritten, if they exist.\n\u0026gt;\u0026gt;\u0026gt; app.to_csv(\u0026#34;my exciting view\u0026#34;, out_dir=\u0026#34;_csv\u0026#34;) Working with Record Objects #  Record objects are dict-like containers for Knack record data. Note that all timestamps have been correctly set to unix time.\nYou can access a record value like you would a dict, using the field key or field name.\n\u0026gt;\u0026gt;\u0026gt; record = app.get(\u0026#34;object_1\u0026#34;)[0] # access a value via field key \u0026gt;\u0026gt;\u0026gt; record[\u0026#34;field_22\u0026#34;] {\u0026#34;city\u0026#34;: \u0026#34;Austin\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;TX\u0026#34;, \u0026#34;street\u0026#34;: \u0026#34;8700 Cameron Rd\u0026#34;, \u0026#34;street2\u0026#34;: \u0026#34;Suite 1\u0026#34;, \u0026#34;zip\u0026#34;: \u0026#34;78754\u0026#34;} # access a value via field name \u0026gt;\u0026gt;\u0026gt; record[\u0026#34;Customer Address\u0026#34;] {\u0026#34;city\u0026#34;: \u0026#34;Austin\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;TX\u0026#34;, \u0026#34;street\u0026#34;: \u0026#34;8700 Cameron Rd\u0026#34;, \u0026#34;street2\u0026#34;: \u0026#34;Suite 1\u0026#34;, \u0026#34;zip\u0026#34;: \u0026#34;78754\u0026#34;} Formatting Records #  Format the keys and/or values of a record.\n# format keys and values \u0026gt;\u0026gt;\u0026gt; formatted_record = record.format() { \u0026#34;id\u0026#34;: \u0026#34;abc123xyz789\u0026#34;, \u0026#34;Customer Address\u0026#34;: \u0026#34;8700 Cameron Rd, Austin, TX, 78754\u0026#34; } # only format the keys \u0026gt;\u0026gt;\u0026gt; formatted_keys = record.format(values=False) { \u0026#34;id\u0026#34;: \u0026#34;abc123xyz789\u0026#34;, \u0026#34;Customer Address\u0026#34;: {\u0026#34;city\u0026#34;: \u0026#34;Austin\u0026#34;, \u0026#34;state\u0026#34;: \u0026#34;TX\u0026#34;, \u0026#34;street\u0026#34;: \u0026#34;8700 Cameron Rd\u0026#34;, \u0026#34;street2\u0026#34;: \u0026#34;Suite 1\u0026#34;, \u0026#34;zip\u0026#34;: \u0026#34;78754\u0026#34;}} # only format the values \u0026gt;\u0026gt;\u0026gt; formatted_values = record.format(keys=False) { \u0026#34;id\u0026#34;: \u0026#34;abc123xyz789\u0026#34;, \u0026#34;field_22\u0026#34;: \u0026#34;8700 Cameron Rd, Austin, TX, 78754\u0026#34; } # format specific keys and values \u0026gt;\u0026gt;\u0026gt; formatted_values = record.format(keys=[\u0026#34;field_22\u0026#34;], values=[\u0026#34;field_22\u0026#34;]) { \u0026#34;id\u0026#34;: \u0026#34;abc123xyz789\u0026#34;, \u0026#34;Customer Address\u0026#34;: \u0026#34;8700 Cameron Rd, Austin, TX, 78754\u0026#34; } Although a Record object looks like a dict, it contains Field objects (TODO: link to docs). If you want to convert a Record object into a plain-old dict, use the dict() built-in.\n\u0026gt;\u0026gt;\u0026gt; record = app.get(\u0026#34;object_1\u0026#34;)[0] \u0026gt;\u0026gt;\u0026gt; data = dict(record) Dict-like Record methods (Items, Keys, and Names) #   Record.items(): returns a list of the knackpy Field objects contained within the Record. Record.keys(): returns a list (not a view) of the record\u0026rsquo;s field keys. Record.names(): returns a list of the record\u0026rsquo;s field names.  Accessing Raw Knack Data Records may look raw, but any timestamps have been corrected to real unix time. If you want the raw, untouched data, use the Record.raw property.  Accessing the API Directly #  If you don\u0026rsquo;t want to fuss with App objects, you can use knackpy\u0026rsquo;s direct interface with the Knack API.\n# This is equivalent to exporting records in JSON format from the Knack Builder \u0026gt;\u0026gt;\u0026gt; import knackpy \u0026gt;\u0026gt;\u0026gt; data = knackpy.get( ... app_id=\u0026#34;myappid\u0026#34;, ... api_key=\u0026#34;myverysecretapikey\u0026#34;, ... obj=\u0026#34;object_1\u0026#34;, ... record_limit=None, ... timeout=30 ... ) See the API module documentation for further detail.\nTimestamps and Localization #  Although the Knack API returns timestamp values as Unix timestamps in millesconds, these raw values represent millisecond timestamps in your localized timezone. For example a Knack timestamp value of 1578254700000 represents Sunday, January 5, 2020 8:05:00 PM local time.\nTo address this, the App class converts Knack timestamps into real (UTC-based) unix timestamps. Timestamps are corrected by referencing the timezone info in your apps metadata. You can manually override your app\u0026rsquo;s timezone information by passing an IANA-compliant timezone string to your App instance, like so:\n\u0026gt;\u0026gt;\u0026gt; app = knackpy.App(app_id=\u0026#34;myappid\u0026#34;, api_key=\u0026#34;myverysecretapikey\u0026#34;, tzinfo=\u0026#34;US/Eastern\u0026#34;) If you\u0026rsquo;d like to access your raw, uncorrected records, they can be found at App.data[\u0026lt;container_name:str\u0026gt;].\nNote also that Record objects return corrected timestamps via Record.raw and Record.format(). So,\n\u0026gt;\u0026gt;\u0026gt; app = knackpy.App(app_id=\u0026#34;myappid\u0026#34;, api_key=\u0026#34;myverysecretapikey\u0026#34;, tzinfo=\u0026#34;US/Eastern\u0026#34;) # yields raw records with corrected millisecond timestamps \u0026gt;\u0026gt;\u0026gt; records_raw = [record.raw for record in app.get(\u0026#34;object_3\u0026#34;)] # yields corrected timestamps as ISO-8601 strings \u0026gt;\u0026gt;\u0026gt; records_formatted = [record.format() for record in app.get(\u0026#34;object_3\u0026#34;)] Exceptions #  Knackpy uses Python\u0026rsquo;s built-in exceptions, as well as Requests\u0026rsquo;s exceptions when interacting with the Knack API.\nIf you need to inspect an API exception (for example to see the text content of the response), you can access the Response object by handling the exception like so:\n\u0026gt;\u0026gt;\u0026gt; import requests \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; app = knackpy.App(api_key=\u0026#34;myappid\u0026#34;) # raises HTTPError. You cannot request object records without supplying an API key \u0026gt;\u0026gt;\u0026gt; try: ... records = app.get(\u0026#34;object_1\u0026#34;) ... except requests.exceptions.HTTPError as e: ... print(e.response.text) ... raise e # \u0026#39;Unauthorized Object Access\u0026#39; "});})();